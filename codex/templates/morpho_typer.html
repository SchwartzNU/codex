{% extends "base.html" %}

{% block title %}
Morpho-Typer
{% endblock title %}

{% block content %}
<nav class="navbar navbar-light bg-light">
    <form class="form-inline">
        <select class="form-control mr-sm-2" style="width: 20vw;" id="f_type_string" name="f_type_string" aria-label="f_type_input">
            <option value="" {% if not f_type_string %}selected{% endif %}>Cell Type (human)</option>
            {# Options will be populated dynamically based on Cell Class #}
        </select>
        <input class="form-control mr-sm-2" style="width: 20vw;" autocomplete="off" type="search"
               id="m_type_string" name="m_type_string" placeholder="Cell Type (machine)" aria-label="m_type_input"
               value="{{ m_type_string }}">
        <select class="form-control mr-sm-2" style="width: 12vw;" id="cell_class" name="cell_class" aria-label="cell_class_input">
            <option value="" {% if not cell_class %}selected{% endif %}>Cell Class</option>
            <option value="RGC" {% if cell_class == 'RGC' %}selected{% endif %}>RGC</option>
            <option value="AC" {% if cell_class == 'AC' %}selected{% endif %}>AC</option>
            <option value="BC" {% if cell_class == 'BC' %}selected{% endif %}>BC</option>
            <option value="HC" {% if cell_class == 'HC' %}selected{% endif %}>HC</option>
            <option value="Glia" {% if cell_class == 'Glia' %}selected{% endif %}>Glia</option>
        </select>
        <input class="form-control mr-sm-2" style="width: 50vw;" autocomplete="off" type="search"
               id="seg_ids_string" name="seg_ids_string" placeholder="seg_ids"
               aria-label="seg_id_input" value="{{ seg_ids_string }}">
        
        <button class="btn btn-primary my-2 my-sm-0" type="submit">
            <i class="fa-solid fa-magnifying-glass"></i>
        </button>
    </form>
</nav>

<div class="container-fluid">
  <div class="row">
    <!-- Skeletons Table -->
    <div class="col-md-6">
      <div class="card bg-light mb-3" style="margin: 5px;">
        <div class="card-header d-flex justify-content-between align-items-center" style="color: purple; font-size: 18px;">
          <div class="d-flex align-items-center">
            <button id="skeletons-toggle" class="btn btn-link btn-sm p-0 mr-2" data-toggle="collapse" data-target="#collapse-skeletons" aria-expanded="true" aria-controls="collapse-skeletons" title="Toggle">
              <i id="skeletons-chevron" class="fa fa-chevron-down"></i>
            </button>
            <span>Skeletons</span>
          </div>
          <div class="form-check" style="font-size: 12px; margin-bottom: 0;">
            <input class="form-check-input" type="checkbox" id="lock-scale" />
            <label class="form-check-label" for="lock-scale">Lock scale across rows</label>
          </div>
        </div>
        <div id="collapse-skeletons" class="collapse show">
        <div class="card-body">
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col" style="width: 1%; white-space: nowrap;">Segment ID</th>
                <th scope="col" style="width: 49%;">Front/Side View</th>
                <th scope="col" style="width: 50%;">Stratification</th>
              </tr>
            </thead>
            <tbody>
              {% for i in range(seg_ids|length) %}
                <tr class="skeleton-row" data-segid="{{ seg_ids[i] }}" style="cursor:pointer;">
                  <td style="vertical-align: middle; width: 1%; white-space: nowrap;">
                    <span class="badge badge-pill badge-light text-dark segid-badge" 
                          style="font-size: 0.60rem; padding: 2px 6px; border: 1px solid #ddd; user-select: text;">
                      {{ seg_ids[i] }}
                    </span>
                  </td>
                  <td>
                    <iframe class="plot-iframe" src="{{ url_for('app.skeleton_plot') }}?segid={{ seg_ids[i] }}" 
                            title="Skeleton {{ seg_ids[i] }}"
                            width="100%" height="230" loading="lazy"
                            style="border: 1px solid #ccc; border-radius: 3px; background:#f8f9fa; display:block; overflow:hidden;"></iframe>
                  </td>
                  <td>
                    <iframe class="plot-iframe" src="{{ url_for('app.strat_plot') }}?segid={{ seg_ids[i] }}" 
                            title="Stratification {{ seg_ids[i] }}"
                            width="100%" height="230" loading="lazy"
                            style="border: 1px solid #ccc; border-radius: 3px; background:#f8f9fa; display:block; overflow:hidden;"></iframe>
                  </td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
        </div>
      </div>
    </div>

    <!-- Neuroglancer + Stats -->
    <div class="col-md-6">
      <!-- Neuroglancer view -->
      <div class="card bg-light mb-3" style="margin: 5px;">
        <div class="card-header d-flex justify-content-between align-items-center" style="color: purple; font-size: 18px;">
          <div class="d-flex align-items-center">
            <button id="ng-toggle" class="btn btn-link btn-sm p-0 mr-2" data-toggle="collapse" data-target="#collapse-ng" aria-expanded="true" aria-controls="collapse-ng" title="Toggle">
              <i id="ng-chevron" class="fa fa-chevron-down"></i>
            </button>
            <span>Neuroglancer view</span>
          </div>
        </div>
        <div id="collapse-ng" class="collapse show">
        <div class="card-body">
          <div id="ng-share-feedback" class="alert py-1 px-2" role="alert" style="display:none; margin-bottom: 6px;"></div>
          <div class="d-flex justify-content-end" style="margin-bottom: 6px; gap: 6px;">
            <button id="btn-open-ng" class="btn btn-sm btn-outline-primary" disabled>Open Viewer</button>
            <button id="btn-short-ng" class="btn btn-sm btn-outline-success" disabled>Shorten + Copy</button>
            <div class="input-group input-group-sm" style="width: auto;">
              <div class="input-group-prepend">
                <label class="input-group-text" for="export-format">Export</label>
              </div>
              <select id="export-format" class="custom-select">
                <option value="csv" selected>.csv</option>
                <option value="pickle">.pkl (pickle)</option>
                <option value="mat">.mat (MATLAB)</option>
                <option value="h5">.h5 (HDF5)</option>
              </select>
              <div class="input-group-append">
                <button id="btn-export" class="btn btn-sm btn-outline-secondary" disabled>Export Data Table</button>
              </div>
            </div>
          </div>
          <iframe id="ng-iframe" src="" width="100%" height="400"
                  allow="clipboard-read; clipboard-write; fullscreen"
                  style="border:1px solid #ccc; border-radius: 4px;"></iframe>
        </div>
        </div>
      </div>

      <!-- Population Stats -->
      <div class="card bg-light mb-3" style="margin: 5px;">
        <div class="card-header d-flex justify-content-between align-items-center" style="color: purple; font-size: 18px;">
          <div class="d-flex align-items-center">
            <button id="pop-toggle" class="btn btn-link btn-sm p-0 mr-2" data-toggle="collapse" data-target="#collapse-pop" aria-expanded="true" aria-controls="collapse-pop" title="Toggle">
              <i id="pop-chevron" class="fa fa-chevron-down"></i>
            </button>
            <span>Population Stats and Coverage</span>
          </div>
        </div>
        <div id="collapse-pop" class="collapse show">
        <div class="card-body">
          <table id="population-stats-table" class="table table-bordered">
            <thead>
              <tr><th>Statistic</th><th>Value</th><th>Units</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        </div>
      </div>

      <!-- Selected Cell Stats -->
      <div id="selected-stats-card" class="card bg-light mb-3" style="margin: 5px;">
        <div class="card-header d-flex justify-content-between align-items-center" style="color: purple; font-size: 18px;">
          <div class="d-flex align-items-center">
            <button id="sel-toggle" class="btn btn-link btn-sm p-0 mr-2" data-toggle="collapse" data-target="#collapse-sel" aria-expanded="true" aria-controls="collapse-sel" title="Toggle">
              <i id="sel-chevron" class="fa fa-chevron-down"></i>
            </button>
            <span>Selected Cell Stats</span>
          </div>
        </div>
        <div id="collapse-sel" class="collapse show">
        <div class="card-body">
          <table id="selected-stats-table" class="table table-bordered">
            <thead>
              <tr><th>Statistic</th><th>Value</th><th>Units</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
    // array of soma positions from server-side context
    const somaPos = {{ soma_pos|tojson }};
    const cellTypesByClass = {{ cell_types_by_class|tojson }};
document.addEventListener('DOMContentLoaded', async function() {
  // Keep collapse chevron in sync for Skeletons card
  $("#collapse-skeletons").on('show.bs.collapse', function(){
    document.getElementById('skeletons-chevron')?.classList.replace('fa-chevron-right', 'fa-chevron-down');
  });
  $("#collapse-skeletons").on('hide.bs.collapse', function(){
    document.getElementById('skeletons-chevron')?.classList.replace('fa-chevron-down', 'fa-chevron-right');
  });
  // Neuroglancer card chevron sync
  $("#collapse-ng").on('show.bs.collapse', function(){
    document.getElementById('ng-chevron')?.classList.replace('fa-chevron-right', 'fa-chevron-down');
  });
  $("#collapse-ng").on('hide.bs.collapse', function(){
    document.getElementById('ng-chevron')?.classList.replace('fa-chevron-down', 'fa-chevron-right');
  });
  // Population card chevron sync
  $("#collapse-pop").on('show.bs.collapse', function(){
    document.getElementById('pop-chevron')?.classList.replace('fa-chevron-right', 'fa-chevron-down');
  });
  $("#collapse-pop").on('hide.bs.collapse', function(){
    document.getElementById('pop-chevron')?.classList.replace('fa-chevron-down', 'fa-chevron-right');
  });
  // Selected stats card chevron sync
  $("#collapse-sel").on('show.bs.collapse', function(){
    document.getElementById('sel-chevron')?.classList.replace('fa-chevron-right', 'fa-chevron-down');
  });
  $("#collapse-sel").on('hide.bs.collapse', function(){
    document.getElementById('sel-chevron')?.classList.replace('fa-chevron-down', 'fa-chevron-right');
  });
  // Auto-resize plot iframes to fit their content height
  function resizeIframe(iframe) {
    if (!iframe || !iframe.contentWindow) return;
    try {
      const doc = iframe.contentWindow.document;
      if (!doc) return;
      const h1 = doc.documentElement ? doc.documentElement.scrollHeight : 0;
      const h2 = doc.body ? doc.body.scrollHeight : 0;
      const newH = Math.max(h1, h2, 200);
      // add a little padding to avoid cut-off
      iframe.style.height = (newH + 8) + 'px';
    } catch (e) {
      // Cross-origin shouldn't happen here; fail silently
    }
  }
  function attachIframeAutoResize() {
    const iframes = document.querySelectorAll('iframe.plot-iframe');
    iframes.forEach(ifr => {
      // initial adjustment after load
      ifr.addEventListener('load', () => {
        // resize immediately and again after a short delay for Plotly render
        resizeIframe(ifr);
        setTimeout(() => resizeIframe(ifr), 250);
        setTimeout(() => resizeIframe(ifr), 800);
      }, { once: false });
    });
  }
  attachIframeAutoResize();
  // Also respond to window resizes
  // Debounced window resize handler
  (function(){
    let t = null;
    window.addEventListener('resize', () => {
      if (t) clearTimeout(t);
      t = setTimeout(() => {
        document.querySelectorAll('iframe.plot-iframe').forEach(resizeIframe);
      }, 150);
    });
  })();
  // Populate f_type_string options based on cell_class selection
  function populateHumanTypes(selectedClass, selectedType) {
    const fTypeSelect = document.getElementById('f_type_string');
    if (!fTypeSelect) return;
    // Clear existing options except placeholder
    fTypeSelect.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Cell Type (human)';
    fTypeSelect.appendChild(placeholder);

    let types = [];
    if (selectedClass && cellTypesByClass) {
      // Try exact match first, then case-insensitive fallback
      let key = selectedClass;
      if (!cellTypesByClass[key]) {
        const found = Object.keys(cellTypesByClass).find(k => k.trim().toLowerCase() === selectedClass.trim().toLowerCase());
        if (found) key = found;
      }
      if (cellTypesByClass[key]) {
        types = cellTypesByClass[key];
      }
    }
    types.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = t;
      if (selectedType && selectedType === t) opt.selected = true;
      fTypeSelect.appendChild(opt);
    });
  }

  const cellClassSel = document.getElementById('cell_class');
  const initialSelectedClass = cellClassSel ? cellClassSel.value : '';
  const initialSelectedType = {{ f_type_string|tojson }};
  populateHumanTypes(initialSelectedClass, initialSelectedType);

  if (cellClassSel) {
    cellClassSel.addEventListener('change', () => {
      populateHumanTypes(cellClassSel.value, '');
    });
  }

  async function renderPopulationStats(doIndices) {
    const popTbody = document.querySelector('#population-stats-table tbody');
    popTbody.innerHTML = '';
    // Prefer somaPos count; fallback to number of rendered segids
    const count = (Array.isArray(somaPos) && somaPos.length ? somaPos.length : (typeof segids !== 'undefined' ? segids.length : 0));
    // Always show # cells
    const trCount = document.createElement('tr');
    ["# cells", count, 'count'].forEach(text => {
      const td = document.createElement('td');
      td.textContent = (text !== null && text !== undefined) ? text : '';
      trCount.appendChild(td);
    });
    popTbody.appendChild(trCount);
    if (!doIndices || !somaPos || !Array.isArray(somaPos) || somaPos.length === 0) return;
    try {
      const resp = await fetch('/app/population_stats', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({soma_pos: somaPos})
      });
      const {vdri, nnri} = await resp.json();
      [["VDRI", vdri, ''], ["NNRI", nnri, '']].forEach(([k, v, u]) => {
        const tr = document.createElement('tr');
        [k, v, u].forEach(text => {
          const td = document.createElement('td');
          td.textContent = (text !== null && text !== undefined) ? text : '';
          tr.appendChild(td);
        });
        popTbody.appendChild(tr);
      });
    } catch (err) {
      console.error('Population stats fetch error', err);
    }
  }

  const rows = document.querySelectorAll('.skeleton-row');
  const segids = Array.from(rows).map(r => r.dataset.segid);
  const ngFrame = document.getElementById('ng-iframe');
  let latestNgUrl = '';
  let selectedSegId = null;

  // Always render population count; add indices only if enabled
  await renderPopulationStats(true);

  async function fetchAndRenderStatsFor(segid) {
    if (!segid) return;
    try {
      const res = await fetch(`/app/arbor_stats/${segid}`);
      const text = await res.text();
      let data;
      try {
        data = JSON.parse(text);
      } catch (parseErr) {
        console.error('JSON parse error:', parseErr);
        return;
      }
      const { stats, units } = data || {};
      const tbody = document.querySelector('#selected-stats-table tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      if (!stats || typeof stats !== 'object') return;
      Object.entries(stats).forEach(([key, value]) => {
        if (Array.isArray(value)) return;
        const tr = document.createElement('tr');
        ['td', 'td', 'td'].forEach((tag, i) => {
          const cell = document.createElement(tag);
          if (i === 0) cell.textContent = key;
          if (i === 1) cell.textContent = value;
          if (i === 2) cell.textContent = (units && units[key]) ? units[key] : '';
          tr.appendChild(cell);
        });
        tbody.appendChild(tr);
      });
    } catch (e) {
      console.error('Stats fetch error', e);
    }
  }

  // Removed Show Stats toggle; cards are collapsible instead

  // initial Neuroglancer load
  if (segids.length && ngFrame) {
    const params = new URLSearchParams();
    segids.forEach(id => params.append('segids', id));
    params.append('selected', segids[0]);
    try {
      // Prefer server-side short URL; always try long URL fallback to ensure update
      let gotShort = false;
      try {
        const shortRes = await fetch(`/app/neuroglancer_shorten?${params.toString()}`);
        const shortData = await shortRes.json();
        if (shortRes.ok && shortData.short_url) {
          latestNgUrl = shortData.short_url;
          ngFrame.src = latestNgUrl;
          gotShort = true;
        }
      } catch (e) {
        console.warn('Server shorten failed:', e);
      }
      // Always fetch long URL as reliable fallback
      try {
        const res = await fetch(`/app/neuroglancer_url?${params.toString()}`);
        const data = await res.json();
        if (data.url) {
          latestNgUrl = data.url;
          if (!gotShort) ngFrame.src = data.url;
        }
      } catch (e) {
        console.warn('Long URL fetch failed:', e);
      }
      enableNgButtons();
    } catch (e) {
      console.error(e);
    }
    // Track initial selection for later stats toggle
    selectedSegId = segids[0];
  }

  rows.forEach(row => {
    row.addEventListener('click', async () => {
      console.log('Row clicked, segid:', row.dataset.segid);
      rows.forEach(r => r.style.backgroundColor = '');
      row.style.backgroundColor = '#e0d7f7';
      const segid = row.dataset.segid;
      selectedSegId = segid;
      

      // update Neuroglancer
      const params = new URLSearchParams();
      segids.forEach(id => params.append('segids', id));
      params.append('selected', segid);
      try {
      // Prefer server-side short URL; always try long URL fallback to ensure update
      let gotShort = false;
      try {
        const shortRes = await fetch(`/app/neuroglancer_shorten?${params.toString()}`);
        const shortData = await shortRes.json();
        if (shortRes.ok && shortData.short_url) {
          latestNgUrl = shortData.short_url;
          ngFrame.src = latestNgUrl;
          gotShort = true;
        }
      } catch (e) {
        console.warn('Server shorten failed:', e);
      }
      // Always fetch long URL as reliable fallback
      try {
        const res = await fetch(`/app/neuroglancer_url?${params.toString()}`);
        const d = await res.json();
        if (d.url) {
          console.log('Neuroglancer URL:', d.url);
          latestNgUrl = d.url;
          if (!gotShort) ngFrame.src = d.url;
        }
      } catch (e) {
        console.warn('Long URL fetch failed:', e);
      }
      enableNgButtons();
      } catch (e) {
        console.error(e);
      }

      // fetch and populate Selected Cell Stats (only if enabled)
      const tbody = document.querySelector('#selected-stats-table tbody');
      if (tbody) tbody.innerHTML = '';
      await fetchAndRenderStatsFor(segid);
    });
  });
  // Allow copying segment ID without triggering row click
  document.querySelectorAll('.segid-badge').forEach(el => {
    el.addEventListener('click', ev => ev.stopPropagation());
    el.addEventListener('mousedown', ev => ev.stopPropagation());
  });

  // Share toolbar logic
  function enableNgButtons() {
    const openBtn = document.getElementById('btn-open-ng');
    const shortBtn = document.getElementById('btn-short-ng');
    const exportBtn = document.getElementById('btn-export');
    [openBtn, shortBtn].forEach(b => b && (b.disabled = !latestNgUrl));
    if (exportBtn) exportBtn.disabled = !(segids && segids.length);
  }

  function showNgFeedback(message, level) {
    const box = document.getElementById('ng-share-feedback');
    if (!box) return;
    // reset classes
    box.classList.remove('alert-success', 'alert-warning', 'alert-danger', 'alert-info');
    const cls = level === 'success' ? 'alert-success'
              : level === 'warning' ? 'alert-warning'
              : level === 'danger' ? 'alert-danger'
              : 'alert-info';
    box.classList.add(cls);
    box.textContent = message;
    box.style.display = 'block';
    try { box.scrollIntoView({behavior: 'smooth', block: 'nearest'}); } catch {}
    clearTimeout(window.__ngShareMsgTimer);
    window.__ngShareMsgTimer = setTimeout(() => { box.style.display = 'none'; }, 3000);
  }
  document.getElementById('btn-open-ng')?.addEventListener('click', () => {
    if (latestNgUrl) window.open(latestNgUrl, '_blank');
  });

  // Uniform scaling toggle
  async function computeGlobalRanges(ids) {
    const params = new URLSearchParams();
    ids.forEach(id => params.append('segids', id));
    const res = await fetch(`/app/plot_ranges?${params.toString()}`);
    if (!res.ok) throw new Error('plot_ranges failed');
    return await res.json();
  }
  function withRanges(url, ranges) {
    if (!ranges) return url;
    const u = new URL(url, window.location.origin);
    // skeleton_plot needs xy and xz ranges
    if (u.pathname.endsWith('/skeleton_plot')) {
      const xy = ranges.xy, xz = ranges.xz;
      if (xy) {
        u.searchParams.set('xlim_xy', `${xy.x[0]},${xy.x[1]}`);
        u.searchParams.set('ylim_xy', `${xy.y[0]},${xy.y[1]}`);
      }
      if (xz) {
        u.searchParams.set('xlim_xz', `${xz.x[0]},${xz.x[1]}`);
        u.searchParams.set('ylim_xz', `${xz.z[0]},${xz.z[1]}`); // z maps to y in XZ
      }
    }
    // strat_plot always uses fixed Z range (-20,30) across rows; do not override
    return u.toString();
  }
  async function applyScaleLock(locked) {
    const iframes = document.querySelectorAll('iframe.plot-iframe');
    if (!locked) {
      // reload without extra params
      iframes.forEach(ifr => {
        const u = new URL(ifr.src, window.location.origin);
        // keep segid param only
        const segid = u.searchParams.get('segid');
        const bare = `${u.origin}${u.pathname}?segid=${encodeURIComponent(segid)}`;
        ifr.src = bare;
      });
      return;
    }
    try {
      const ranges = await computeGlobalRanges(segids);
      iframes.forEach(ifr => {
        ifr.src = withRanges(ifr.src, ranges);
      });
    } catch (e) {
      console.warn('Failed to lock scale', e);
    }
  }
  const lockChk = document.getElementById('lock-scale');
  if (lockChk) {
    lockChk.addEventListener('change', () => applyScaleLock(lockChk.checked));
  }
  document.getElementById('btn-short-ng')?.addEventListener('click', async () => {
    if (!segids.length) return;
    const params = new URLSearchParams();
    segids.forEach(id => params.append('segids', id));
    params.append('selected', segids[0]);
    try {
      const res = await fetch(`/app/neuroglancer_shorten?${params.toString()}`);
      let shortUrl = null;
      let errDetail = '';
      try {
        const ct = res.headers.get('content-type') || '';
        if (ct.includes('application/json')) {
          const d = await res.json();
          if (d && d.short_url) shortUrl = d.short_url;
          else if (d && d.error) errDetail = d.error;
        } else {
          const txt = await res.text();
          errDetail = txt ? txt.slice(0, 140) : '';
        }
      } catch (_) {}

      if (res.ok && shortUrl) {
        const dShort = shortUrl;
        latestNgUrl = d.short_url;
        let copied = false;
        try { await navigator.clipboard.writeText(latestNgUrl); copied = true; } catch (e) { copied = false; }
        ngFrame.src = latestNgUrl;
        enableNgButtons();
        showNgFeedback(copied ? 'Short link copied to clipboard' : 'Short link ready (copy blocked)', copied ? 'success' : 'warning');
      } else {
        const msg = `Shorten failed${res.status ? ` (${res.status})` : ''}. Using long URL instead.`;
        console.warn('Shorten failed:', res.status, errDetail);
        showNgFeedback(msg, 'danger');
        // Fetch long URL as immediate fallback and keep UX responsive
        try {
          const res2 = await fetch(`/app/neuroglancer_url?${params.toString()}`);
          const d2 = await res2.json();
          if (d2 && d2.url) {
            latestNgUrl = d2.url;
            ngFrame.src = latestNgUrl;
            enableNgButtons();
          }
        } catch (_) {}
      }
    } catch (e) {
      console.error('Shorten failed', e);
      showNgFeedback('Shorten failed due to a network error.', 'danger');
    }
  });

  // Export data table
  document.getElementById('btn-export')?.addEventListener('click', (ev) => {
    ev.preventDefault();
    if (!(segids && segids.length)) return;
    const fmtSel = document.getElementById('export-format');
    const fmt = fmtSel ? fmtSel.value : 'csv';
    const params = new URLSearchParams();
    segids.forEach(id => params.append('segids', id));
    params.append('format', fmt);
    const url = `/app/export_arbor_stats?${params.toString()}`;
    // Trigger download (single file; CSV includes units on row 2)
    const a = document.createElement('a');
    a.href = url;
    a.setAttribute('download', '');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  });
});
</script>
{% endblock content %}
