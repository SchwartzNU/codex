{% extends "base.html" %}

{% block title %}
Morpho-Typer
{% endblock title %}

{% block head_extra %}
  <!-- Ensure Plotly is loaded -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    .plot-cell {
      min-width: 340px;
      max-width: 520px;
      vertical-align: top;
    }
    .plot-host {
      width: 100%;
      height: 380px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: white;
      overflow: visible;
    }
    @media (max-width: 1200px) {
      .plot-host { height: 320px; }
    }
    @media (max-width: 992px) {
      .plot-host { height: 280px; }
    }
  </style>
{% endblock head_extra %}

{% block content %}
<nav class="navbar navbar-light bg-light">
    <form class="form-inline">
        <select class="form-control mr-sm-2" style="width: 20vw;" id="f_type_string" name="f_type_string" aria-label="f_type_input">
            <option value="" {% if not f_type_string %}selected{% endif %}>Cell Type (human)</option>
            {# Options will be populated dynamically based on Cell Class #}
        </select>
        <input class="form-control mr-sm-2" style="width: 20vw;" autocomplete="off" type="search"
               id="m_type_string" name="m_type_string" placeholder="Cell Type (machine)" aria-label="m_type_input"
               value="{{ m_type_string }}">
        <select class="form-control mr-sm-2" style="width: 12vw;" id="cell_class" name="cell_class" aria-label="cell_class_input">
            <option value="" {% if not cell_class %}selected{% endif %}>Cell Class</option>
            <option value="RGC" {% if cell_class == 'RGC' %}selected{% endif %}>RGC</option>
            <option value="AC" {% if cell_class == 'AC' %}selected{% endif %}>AC</option>
            <option value="BC" {% if cell_class == 'BC' %}selected{% endif %}>BC</option>
            <option value="HC" {% if cell_class == 'HC' %}selected{% endif %}>HC</option>
            <option value="Glia" {% if cell_class == 'Glia' %}selected{% endif %}>Glia</option>
        </select>
        <input class="form-control mr-sm-2" style="width: 50vw;" autocomplete="off" type="search"
               id="seg_ids_string" name="seg_ids_string" placeholder="seg_ids"
               aria-label="seg_id_input" value="{{ seg_ids_string }}">
        <div class="form-check form-check-inline" style="margin-right: 10px;">
          <input class="form-check-input" type="checkbox" id="stats_enabled" name="stats_enabled" value="1" {% if stats_enabled %}checked{% endif %}>
          <label class="form-check-label" for="stats_enabled">Show Stats</label>
        </div>
        <button class="btn btn-primary my-2 my-sm-0" type="submit">
            <i class="fa-solid fa-magnifying-glass"></i>
        </button>
    </form>
</nav>

<div class="container-fluid">
  <div class="row">
    <!-- Skeletons Table -->
    <div class="col-md-6">
      <div class="card bg-light mb-3" style="margin: 5px;">
        <div class="card-header" style="color: purple; font-size: 18px;">
          Skeletons
        </div>
        <div class="card-body">
          <table class="table table-striped">
            <thead>
              <tr>
                <th scope="col">Segment ID</th>
                <th scope="col">Front/Side View</th>
                <th scope="col">Stratification</th>
              </tr>
            </thead>
            <tbody>
              {% for i in range(seg_ids|length) %}
                <tr class="skeleton-row" data-segid="{{ seg_ids[i] }}" style="cursor:pointer;">
                  <td style="vertical-align: middle;">
                    <span class="badge badge-pill badge-light text-dark segid-badge" 
                          style="font-size: 0.70rem; border: 1px solid #ddd; user-select: text;">
                      {{ seg_ids[i] }}
                    </span>
                  </td>
                  <td class="plot-cell"><div class="plot-host" id="skel-host-{{ i }}"></div></td>
                  <td class="plot-cell"><div class="plot-host" id="strat-host-{{ i }}"></div></td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Neuroglancer + Stats -->
    <div class="col-md-6">
      <!-- Neuroglancer view -->
      <div class="card bg-light mb-3" style="margin: 5px;">
        <div class="card-header" style="color: purple; font-size: 18px;">
          Neuroglancer view
        </div>
        <div class="card-body">
          <div id="ng-share-feedback" class="alert py-1 px-2" role="alert" style="display:none; margin-bottom: 6px;"></div>
          <div class="d-flex justify-content-end" style="margin-bottom: 6px; gap: 6px;">
            <button id="btn-open-ng" class="btn btn-sm btn-outline-primary" disabled>Open Viewer</button>
            <button id="btn-short-ng" class="btn btn-sm btn-outline-success" disabled>Shorten + Copy</button>
            <div class="input-group input-group-sm" style="width: auto;">
              <div class="input-group-prepend">
                <label class="input-group-text" for="export-format">Export</label>
              </div>
              <select id="export-format" class="custom-select">
                <option value="csv" selected>.csv</option>
                <option value="pickle">.pkl (pickle)</option>
                <option value="mat">.mat (MATLAB)</option>
                <option value="h5">.h5 (HDF5)</option>
              </select>
              <div class="input-group-append">
                <button id="btn-export" class="btn btn-sm btn-outline-secondary" disabled>Export Data Table</button>
              </div>
            </div>
          </div>
          <iframe id="ng-iframe" src="" width="100%" height="400"
                  allow="clipboard-read; clipboard-write; fullscreen"
                  style="border:1px solid #ccc; border-radius: 4px;"></iframe>
        </div>
      </div>

      <!-- Population Stats -->
      <div class="card bg-light mb-3" style="margin: 5px;">
        <div class="card-header" style="color: purple; font-size: 18px;">
          Population Stats
        </div>
        <div class="card-body">
          <table id="population-stats-table" class="table table-bordered">
            <thead>
              <tr><th>Statistic</th><th>Value</th><th>Units</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <!-- Selected Cell Stats -->
      <div id="selected-stats-card" class="card bg-light mb-3" style="margin: 5px;{% if not stats_enabled %} display: none;{% endif %}">
        <div class="card-header" style="color: purple; font-size: 18px;">
          Selected Cell Stats
        </div>
        <div class="card-body">
          <table id="selected-stats-table" class="table table-bordered">
            <thead>
              <tr><th>Statistic</th><th>Value</th><th>Units</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(function ensurePlotlyLoaded() {
  if (window.Plotly) {
    document.dispatchEvent(new Event('plotly:ready'));
    return;
  }
  const s = document.createElement('script');
  s.src = 'https://cdn.plot.ly/plotly-2.35.2.min.js'; // pinned version
  s.async = true;
  s.onload = () => document.dispatchEvent(new Event('plotly:ready'));
  s.onerror = () => {
    console.error('Failed to load Plotly bundle.');
    document.dispatchEvent(new Event('plotly:error'));
  };
  document.head.appendChild(s);
})();
</script>

<script>
    // array of soma positions from server-side context
    const somaPos = {{ soma_pos|tojson }};
    const cellTypesByClass = {{ cell_types_by_class|tojson }};
    const skeletonFigs = {{ skeleton_figs|tojson|default('[]')|safe }};
    const stratFigs    = {{ strat_figs|tojson|default('[]')|safe }};

async function waitForPlotly() {
  if (window.Plotly) return;
  await new Promise((resolve, reject) => {
    const onReady = () => { cleanup(); resolve(); };
    const onErr = () => { cleanup(); reject(new Error('Plotly failed to load')); };
    function cleanup() {
      document.removeEventListener('plotly:ready', onReady);
      document.removeEventListener('plotly:error', onErr);
    }
    document.addEventListener('plotly:ready', onReady, { once: true });
    document.addEventListener('plotly:error', onErr, { once: true });
  });
}

document.addEventListener('DOMContentLoaded', async function() {

  try {
    await waitForPlotly();
  } catch (e) {
    console.error(e);
    Array.from(document.querySelectorAll('.plot-host'))
      .forEach(el => el.innerHTML = '<span class="text-danger">Plotly failed to load</span>');
    return; // stop early if Plotly never loaded
  }

  const plotRows = Array.from(document.querySelectorAll('.skeleton-row'));

  function renderRow(i) {
    const skelHost  = document.getElementById(`skel-host-${i}`);
    const stratHost = document.getElementById(`strat-host-${i}`);
    if (!skelHost || !stratHost) return;

    const skelFig  = skeletonFigs[i];
    const stratFig = stratFigs[i];

    if (skelFig && skelFig.data) {
      console.log("Rendering skeleton plot")
      Plotly.newPlot(skelHost, skelFig.data, skelFig.layout || {},
                     {responsive: true, displaylogo: false});
    } else {
      skelHost.innerHTML = '<span class="text-muted">No skeleton plot</span>';
    }

    if (stratFig && stratFig.data) {
      console.log("Rendering stratification plot")
      Plotly.newPlot(stratHost, stratFig.data, stratFig.layout || {},
                     {responsive: true, displaylogo: false});
    } else {
      stratHost.innerHTML = '<span class="text-muted">No stratification plot</span>';
    }
  }

  // Render all rows 
  plotRows.forEach((row, i) => renderRow(i));


  // Populate f_type_string options based on cell_class selection
  function populateHumanTypes(selectedClass, selectedType) {
    const fTypeSelect = document.getElementById('f_type_string');
    if (!fTypeSelect) return;
    // Clear existing options except placeholder
    fTypeSelect.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Cell Type (human)';
    fTypeSelect.appendChild(placeholder);

    let types = [];
    if (selectedClass && cellTypesByClass) {
      // Try exact match first, then case-insensitive fallback
      let key = selectedClass;
      if (!cellTypesByClass[key]) {
        const found = Object.keys(cellTypesByClass).find(k => k.trim().toLowerCase() === selectedClass.trim().toLowerCase());
        if (found) key = found;
      }
      if (cellTypesByClass[key]) {
        types = cellTypesByClass[key];
      }
    }
    types.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = t;
      if (selectedType && selectedType === t) opt.selected = true;
      fTypeSelect.appendChild(opt);
    });
  }

  const cellClassSel = document.getElementById('cell_class');
  const initialSelectedClass = cellClassSel ? cellClassSel.value : '';
  const initialSelectedType = {{ f_type_string|tojson }};
  populateHumanTypes(initialSelectedClass, initialSelectedType);

  if (cellClassSel) {
    cellClassSel.addEventListener('change', () => {
      populateHumanTypes(cellClassSel.value, '');
    });
  }

  async function renderPopulationStats(doIndices) {
    const popTbody = document.querySelector('#population-stats-table tbody');
    popTbody.innerHTML = '';
    // Prefer somaPos count; fallback to number of rendered segids
    const count = (Array.isArray(somaPos) && somaPos.length ? somaPos.length : (typeof segids !== 'undefined' ? segids.length : 0));
    // Always show # cells
    const trCount = document.createElement('tr');
    ["# cells", count, 'count'].forEach(text => {
      const td = document.createElement('td');
      td.textContent = (text !== null && text !== undefined) ? text : '';
      trCount.appendChild(td);
    });
    popTbody.appendChild(trCount);
    if (!doIndices || !somaPos || !Array.isArray(somaPos) || somaPos.length === 0) return;
    try {
      const resp = await fetch('/app/population_stats', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({soma_pos: somaPos})
      });
      const {vdri, nnri} = await resp.json();
      [["VDRI", vdri, ''], ["NNRI", nnri, '']].forEach(([k, v, u]) => {
        const tr = document.createElement('tr');
        [k, v, u].forEach(text => {
          const td = document.createElement('td');
          td.textContent = (text !== null && text !== undefined) ? text : '';
          tr.appendChild(td);
        });
        popTbody.appendChild(tr);
      });
    } catch (err) {
      console.error('Population stats fetch error', err);
    }
  }

  const rows = document.querySelectorAll('.skeleton-row');
  const segids = Array.from(rows).map(r => r.dataset.segid);
  const ngFrame = document.getElementById('ng-iframe');
  const statsCheckbox = document.getElementById('stats_enabled');
  let latestNgUrl = '';
  let selectedSegId = null;

  // Always render population count; add indices only if enabled
  await renderPopulationStats(statsCheckbox ? statsCheckbox.checked : false);

  async function fetchAndRenderStatsFor(segid) {
    if (!segid) return;
    try {
      const res = await fetch(`/app/arbor_stats/${segid}`);
      const text = await res.text();
      let data;
      try {
        data = JSON.parse(text);
      } catch (parseErr) {
        console.error('JSON parse error:', parseErr);
        return;
      }
      const { stats, units } = data || {};
      const tbody = document.querySelector('#selected-stats-table tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      if (!stats || typeof stats !== 'object') return;
      Object.entries(stats).forEach(([key, value]) => {
        if (Array.isArray(value)) return;
        const tr = document.createElement('tr');
        ['td', 'td', 'td'].forEach((tag, i) => {
          const cell = document.createElement(tag);
          if (i === 0) cell.textContent = key;
          if (i === 1) cell.textContent = value;
          if (i === 2) cell.textContent = (units && units[key]) ? units[key] : '';
          tr.appendChild(cell);
        });
        tbody.appendChild(tr);
      });
    } catch (e) {
      console.error('Stats fetch error', e);
    }
  }

  if (statsCheckbox) {
    statsCheckbox.addEventListener('change', async () => {
      // Toggle selected stats card visibility only (no recompute)
      const selCard = document.getElementById('selected-stats-card');
      if (selCard) selCard.style.display = statsCheckbox.checked ? '' : 'none';
      const tbody = document.querySelector('#selected-stats-table tbody');
      if (!statsCheckbox.checked) {
        // Clear when hiding
        if (tbody) tbody.innerHTML = '';
      } else {
        // If showing and a row is currently selected, (re)fetch its stats
        if (tbody) tbody.innerHTML = '';
        if (selectedSegId) {
          await fetchAndRenderStatsFor(selectedSegId);
        }
      }
    });
  }

  // initial Neuroglancer load
  if (segids.length && ngFrame) {
    const params = new URLSearchParams();
    segids.forEach(id => params.append('segids', id));
    params.append('selected', segids[0]);
    try {
      // Prefer server-side short URL; always try long URL fallback to ensure update
      let gotShort = false;
      try {
        const shortRes = await fetch(`/app/neuroglancer_shorten?${params.toString()}`);
        const shortData = await shortRes.json();
        if (shortRes.ok && shortData.short_url) {
          latestNgUrl = shortData.short_url;
          ngFrame.src = latestNgUrl;
          gotShort = true;
        }
      } catch (e) {
        console.warn('Server shorten failed:', e);
      }
      // Always fetch long URL as reliable fallback
      try {
        const res = await fetch(`/app/neuroglancer_url?${params.toString()}`);
        const data = await res.json();
        if (data.url) {
          latestNgUrl = data.url;
          if (!gotShort) ngFrame.src = data.url;
        }
      } catch (e) {
        console.warn('Long URL fetch failed:', e);
      }
      enableNgButtons();
    } catch (e) {
      console.error(e);
    }
    // Track initial selection for later stats toggle
    selectedSegId = segids[0];
  }

  rows.forEach(row => {
    row.addEventListener('click', async () => {
      console.log('Row clicked, segid:', row.dataset.segid);
      rows.forEach(r => r.style.backgroundColor = '');
      row.style.backgroundColor = '#e0d7f7';
      const segid = row.dataset.segid;
      selectedSegId = segid;
      

      // update Neuroglancer
      const params = new URLSearchParams();
      segids.forEach(id => params.append('segids', id));
      params.append('selected', segid);
      try {
      // Prefer server-side short URL; always try long URL fallback to ensure update
      let gotShort = false;
      try {
        const shortRes = await fetch(`/app/neuroglancer_shorten?${params.toString()}`);
        const shortData = await shortRes.json();
        if (shortRes.ok && shortData.short_url) {
          latestNgUrl = shortData.short_url;
          ngFrame.src = latestNgUrl;
          gotShort = true;
        }
      } catch (e) {
        console.warn('Server shorten failed:', e);
      }
      // Always fetch long URL as reliable fallback
      try {
        const res = await fetch(`/app/neuroglancer_url?${params.toString()}`);
        const d = await res.json();
        if (d.url) {
          console.log('Neuroglancer URL:', d.url);
          latestNgUrl = d.url;
          if (!gotShort) ngFrame.src = d.url;
        }
      } catch (e) {
        console.warn('Long URL fetch failed:', e);
      }
      enableNgButtons();
      } catch (e) {
        console.error(e);
      }

      // fetch and populate Selected Cell Stats (only if enabled)
      const tbody = document.querySelector('#selected-stats-table tbody');
      if (tbody) tbody.innerHTML = '';
      if (statsCheckbox && statsCheckbox.checked) {
        await fetchAndRenderStatsFor(segid);
      }
    });
  });
  // Allow copying segment ID without triggering row click
  document.querySelectorAll('.segid-badge').forEach(el => {
    el.addEventListener('click', ev => ev.stopPropagation());
    el.addEventListener('mousedown', ev => ev.stopPropagation());
  });

  // Share toolbar logic
  function enableNgButtons() {
    const openBtn = document.getElementById('btn-open-ng');
    const shortBtn = document.getElementById('btn-short-ng');
    const exportBtn = document.getElementById('btn-export');
    [openBtn, shortBtn].forEach(b => b && (b.disabled = !latestNgUrl));
    if (exportBtn) exportBtn.disabled = !(segids && segids.length);
  }

  function showNgFeedback(message, level) {
    const box = document.getElementById('ng-share-feedback');
    if (!box) return;
    // reset classes
    box.classList.remove('alert-success', 'alert-warning', 'alert-danger', 'alert-info');
    const cls = level === 'success' ? 'alert-success'
              : level === 'warning' ? 'alert-warning'
              : level === 'danger' ? 'alert-danger'
              : 'alert-info';
    box.classList.add(cls);
    box.textContent = message;
    box.style.display = 'block';
    try { box.scrollIntoView({behavior: 'smooth', block: 'nearest'}); } catch {}
    clearTimeout(window.__ngShareMsgTimer);
    window.__ngShareMsgTimer = setTimeout(() => { box.style.display = 'none'; }, 3000);
  }
  document.getElementById('btn-open-ng')?.addEventListener('click', () => {
    if (latestNgUrl) window.open(latestNgUrl, '_blank');
  });
  document.getElementById('btn-short-ng')?.addEventListener('click', async () => {
    if (!segids.length) return;
    const params = new URLSearchParams();
    segids.forEach(id => params.append('segids', id));
    params.append('selected', segids[0]);
    try {
      const res = await fetch(`/app/neuroglancer_shorten?${params.toString()}`);
      let shortUrl = null;
      let errDetail = '';
      try {
        const ct = res.headers.get('content-type') || '';
        if (ct.includes('application/json')) {
          const d = await res.json();
          if (d && d.short_url) shortUrl = d.short_url;
          else if (d && d.error) errDetail = d.error;
        } else {
          const txt = await res.text();
          errDetail = txt ? txt.slice(0, 140) : '';
        }
      } catch (_) {}

      if (res.ok && shortUrl) {
        const dShort = shortUrl;
        latestNgUrl = d.short_url;
        let copied = false;
        try { await navigator.clipboard.writeText(latestNgUrl); copied = true; } catch (e) { copied = false; }
        ngFrame.src = latestNgUrl;
        enableNgButtons();
        showNgFeedback(copied ? 'Short link copied to clipboard' : 'Short link ready (copy blocked)', copied ? 'success' : 'warning');
      } else {
        const msg = `Shorten failed${res.status ? ` (${res.status})` : ''}. Using long URL instead.`;
        console.warn('Shorten failed:', res.status, errDetail);
        showNgFeedback(msg, 'danger');
        // Fetch long URL as immediate fallback and keep UX responsive
        try {
          const res2 = await fetch(`/app/neuroglancer_url?${params.toString()}`);
          const d2 = await res2.json();
          if (d2 && d2.url) {
            latestNgUrl = d2.url;
            ngFrame.src = latestNgUrl;
            enableNgButtons();
          }
        } catch (_) {}
      }
    } catch (e) {
      console.error('Shorten failed', e);
      showNgFeedback('Shorten failed due to a network error.', 'danger');
    }
  });

  // Export data table
  document.getElementById('btn-export')?.addEventListener('click', (ev) => {
    ev.preventDefault();
    if (!(segids && segids.length)) return;
    const fmtSel = document.getElementById('export-format');
    const fmt = fmtSel ? fmtSel.value : 'csv';
    const params = new URLSearchParams();
    segids.forEach(id => params.append('segids', id));
    params.append('format', fmt);
    const url = `/app/export_arbor_stats?${params.toString()}`;
    // Trigger download (single file; CSV includes units on row 2)
    const a = document.createElement('a');
    a.href = url;
    a.setAttribute('download', '');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  });
});
</script>
{% endblock content %}